# 拓展阅读 {#supplement}

## 类 C 语言的 for 循环 {#c-style-for}

```shell
for((assignment;condition;next));do
    command_1;
    command_2;
done;
```

这里的 for 循环与 C 中的相似。我们知道，在 shell 里变量调用需要加 `$`，但是 for 中的 `(())` 中不需要。

!!! example "范例"

    shell 脚本内容：

    ```shell
    #!/bin/bash

    for((i=1;i<=5;i++));do
        echo "这是第 $i 次调用";
    done;
    ```

    输出结果：

    ```text
    这是第 1 次调用
    这是第 2 次调用
    这是第 3 次调用
    这是第 4 次调用
    这是第 5 次调用
    ```

与 C 中相似，赋值和下一步执行可以放到代码之前循环语句之中执行，这里要注意一点：如果要在循环体中进行 for 中的 next 操作，记得变量要加 $，不然程序会变成死循环。

## Fork 炸弹原理解析 {#fork-bomb}

!!! Warning "命令含有危险性"

    以下的命令均包含一定的危险性，请在任何情况下都不要执行，除非你清楚你在做什么。

在[第五章](../Ch05/index.md)中，我们介绍过 fork 炸弹。它通过创建大量进程消耗大量的系统资源，从而拖慢系统与正常进程的运行速度，增大响应时间，使得操作系统的正常运作受到较大影响。[^1]

### 原理 {#fork-bomb-theory}

Fork 炸弹有如下的这种形式：

```shell
:(){ :|: & };:
```

这是一个函数定义以及对其的调用语句，可以格式化为：

```shell
:()
{
    :|: &
};
:
```

在 Bash 中，`:`、`.`、`/` 等一些字符也能够被用于函数命名，因此，上面的代码等价于：

```shell
func()
{
    func | func &
};
func
```

fork 炸弹的核心是函数内容：`func | func &`

-   第一个 func 代表递归执行这个函数。
-   | 代表要将第一个函数的数据结果通过管道传输给后一个函数。
-   & 代表要在后台执行这一条命令，如果其中一个函数被操作系统回收，其调用产生的子函数并不会被回收。

于是运行一次这个函数就会创建两个 func 函数的实例，并不断地反复调用。实例的数量会指数爆炸式地增长，最终耗尽系统的资源。

### 防范方法 {#fork-bomb-prevention}

一个有效的方式[^1]是通过修改系统配置，限制一个用户能够拥有的进程数量多少。`ulimit -u 30` 可以限制当前用户能够拥有的进程数量为 30。

## 引用来源 {#references .no-underline }

[^1]: [Fork Bomb](https://en.wikipedia.org/wiki/Fork_bomb)
